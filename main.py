import logging
import requests
import uuid
import datetime
# import os # Kh√¥ng c·∫ßn thi·∫øt n·∫øu b·∫°n c√†i tr·ª±c ti·∫øp token/ID

from telegram import Update
from telegram.ext import Application, CommandHandler, ContextTypes
from telegram.constants import ParseMode

# --- C·∫•u h√¨nh Logging ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- C·∫•u h√¨nh Bot (Token v√† ID Admin ƒë∆∞·ª£c c√†i tr·ª±c ti·∫øp) ---
# L∆ØU √ù QUAN TR·ªåNG: Vi·ªác nh√∫ng tr·ª±c ti·∫øp token v√† ID v√†o code KH√îNG ƒê∆Ø·ª¢C KHUY·∫æN KH√çCH
# cho m√¥i tr∆∞·ªùng production v√¨ l√Ω do b·∫£o m·∫≠t. N√™n s·ª≠ d·ª•ng bi·∫øn m√¥i tr∆∞·ªùng.
BOT_TOKEN = "8137068939:AAG19xO92yXsz_d9vz_m2aJW2Wh8JZnvSPQ" # Token bot c·ªßa b·∫°n
ADMIN_ID = 6915752059 # ID admin c·ªßa b·∫°n (ƒë·∫£m b·∫£o l√† ki·ªÉu s·ªë nguy√™n)

API_URL = "https://apiluck2.onrender.com/predict"
ADMIN_TELEGRAM_LINK = "t.me/heheviptool"

# --- C·∫•u h√¨nh Webhook c·ª• th·ªÉ cho Render ---
# Render cung c·∫•p c·ªïng v√† URL c√¥ng khai th√¥ng qua bi·∫øn m√¥i tr∆∞·ªùng
# Ch√∫ng ta v·∫´n c·∫ßn ƒë·ªçc PORT v√† PUBLIC_URL t·ª´ bi·∫øn m√¥i tr∆∞·ªùng c·ªßa Render
WEB_SERVER_PORT = int(os.environ.get("PORT", "8080")) # ƒê·ªçc c·ªïng t·ª´ bi·∫øn m√¥i tr∆∞·ªùng c·ªßa Render
WEBHOOK_URL_PATH = "/telegram-webhook"
WEBHOOK_URL = os.environ.get("PUBLIC_URL") + WEBHOOK_URL_PATH if os.environ.get("PUBLIC_URL") else None

# --- Ki·ªÉm tra c√°c bi·∫øn m√¥i tr∆∞·ªùng c·∫ßn thi·∫øt cho Webhook ---
# Ch·ªâ c·∫ßn ki·ªÉm tra PUBLIC_URL v√¨ BOT_TOKEN v√† ADMIN_ID ƒë√£ ƒë∆∞·ª£c c√†i c·ª©ng
if not WEBHOOK_URL:
    logger.error("Thi·∫øu bi·∫øn m√¥i tr∆∞·ªùng PUBLIC_URL. Vui l√≤ng ƒë·∫∑t bi·∫øn n√†y trong m√¥i tr∆∞·ªùng c·ªßa b·∫°n tr√™n Render.")
    exit(1) # Tho√°t ·ª©ng d·ª•ng n·∫øu thi·∫øu PUBLIC_URL

# --- Tr·∫°ng th√°i d·ª± ƒëo√°n ---
prediction_active = False

# --- Qu·∫£n l√Ω Key, Ng∆∞·ªùi d√πng v√† L·ªãch s·ª≠ d·ª± ƒëo√°n ---
active_keys = {}
user_subscriptions = {}
registered_users = set()

# L·ªãch s·ª≠ d·ª± ƒëo√°n ƒë·ªÉ t√≠nh to√°n cho l·ªánh /check
prediction_history = []

# Bi·∫øn ƒë·ªÉ theo d√µi phi√™n cu·ªëi c√πng ƒë√£ g·ª≠i th√¥ng b√°o
last_known_session_id = None

# --- H√†m x·ª≠ l√Ω l·ªánh /start ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name

    registered_users.add(user_id)

    package_status = "Ch∆∞a k√≠ch ho·∫°t"
    expiry_status = "Ch∆∞a k√≠ch ho·∫°t"

    if user_id in user_subscriptions:
        sub_info = user_subscriptions[user_id]
        if sub_info["expiry_date"] > datetime.datetime.now():
            package_status = "ƒê√£ k√≠ch ho·∫°t"
            expiry_status = sub_info["expiry_date"].strftime("%H:%M %d/%m/%Y")
        else:
            del user_subscriptions[user_id]
            for key, info in active_keys.items():
                if info.get("user_id") == user_id:
                    active_keys[key]["user_id"] = None
                    break
            package_status = "ƒê√£ h·∫øt h·∫°n"
            expiry_status = "ƒê√£ h·∫øt h·∫°n"

    response_message = (
        f"üåü CH√ÄO M·ª™NG {user_name} üåü\n\n"
        "üéâ Ch√†o m·ª´ng ƒë·∫øn v·ªõi HeHe Bot üéâ\n\n"
        f"üì¶ G√≥i hi·ªán t·∫°i: {package_status}\n"
        f"‚è∞ H·∫øt h·∫°n: {expiry_status}\n"
        "üí° D√πng /help ƒë·ªÉ xem c√°c l·ªánh\n"
        "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-"
    )
    await update.message.reply_text(response_message)

# --- H√†m x·ª≠ l√Ω l·ªánh /help ---
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    package_status = "Ch∆∞a k√≠ch ho·∫°t"
    if user_id in user_subscriptions and user_subscriptions[user_id]["expiry_date"] > datetime.datetime.now():
        package_status = "ƒê√£ k√≠ch ho·∫°t"

    response_message = (
        f"üì¶ G√≥i hi·ªán t·∫°i: {package_status}\n"
        "üî• C√°c l·ªánh h·ªó tr·ª£:\n"
        "‚úÖ /start - ƒêƒÉng k√Ω v√† b·∫Øt ƒë·∫ßu\n"
        "üîë /key [m√£] - K√≠ch ho·∫°t g√≥i\n"
        "üéÆ /chaymodelbasic - Ch·∫°y d·ª± ƒëo√°n  (LUCK)\n"
        "üõë /stop - D·ª´ng d·ª± ƒëo√°n\n"
        "üõ†Ô∏è /admin - L·ªánh d√†nh cho admin\n"
        "üì¨ Li√™n h·ªá:\n"
        f"üë§ Admin: {ADMIN_TELEGRAM_LINK}\n"
        "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî"
    )
    await update.message.reply_text(response_message)

# --- H√†m g·ª≠i d·ª± ƒëo√°n t·ª´ API ---
async def send_prediction(context: ContextTypes.DEFAULT_TYPE) -> None:
    global prediction_active, last_known_session_id
    chat_id = context.job.chat_id

    if chat_id not in user_subscriptions or user_subscriptions[chat_id]["expiry_date"] <= datetime.datetime.now():
        await context.bot.send_message(chat_id=chat_id, text="G√≥i c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n ho·∫∑c ch∆∞a k√≠ch ho·∫°t. Vui l√≤ng k√≠ch ho·∫°t g√≥i ƒë·ªÉ ti·∫øp t·ª•c nh·∫≠n d·ª± ƒëo√°n.")
        context.job.schedule_removal()
        if chat_id in user_subscriptions:
            del user_subscriptions[chat_id]
        return

    if not prediction_active:
        return

    try:
        response = requests.get(API_URL)
        response.raise_for_status()
        data = response.json()

        phien_moi = data.get("Phien_moi")

        if phien_moi and phien_moi != last_known_session_id:
            last_known_session_id = phien_moi

            matches_list = data.get("matches", [])

            ket_qua_api = ""
            ket_qua_display = "N/A"
            if "t" in matches_list:
                ket_qua_display = "T√ÄI"
                ket_qua_api = "t"
            elif "x" in matches_list:
                ket_qua_display = "X·ªàU"
                ket_qua_api = "x"

            pattern = data.get("pattern", "Kh√¥ng c√≥")
            phien_du_doan = data.get("phien_du_doan", "Kh√¥ng c√≥")
            du_doan_ket_qua = data.get("du_doan", "Kh√¥ng c√≥")

            if du_doan_ket_qua != "Kh√¥ng c√≥" and ket_qua_api:
                prediction_history.append({
                    "phien": phien_moi,
                    "ket_qua_api": ket_qua_api,
                    "du_doan_bot": du_doan_ket_qua
                })
                if len(prediction_history) > 100:
                    prediction_history.pop(0)

            prediction_message = (
                "ü§ñ  ü·¥ú·¥Ñ·¥ã è·¥°…™…¥\n"
                f"üéØ ·¥ò ú…™·¥áÃÇ…¥ {phien_moi}\n"
                f"üé≤ ·¥ã·¥áÃÇÃÅ·¥õ «´·¥ú·¥ÄÃâ : {ket_qua_display} {phien_moi}\n"
                f"üß© ·¥ò·¥Ä·¥õ·¥õ·¥á Ä…¥ : {pattern}\n"
                f"üéÆ ·¥ò ú…™·¥áÃÇ…¥ {phien_du_doan} : {du_doan_ket_qua} (·¥ç·¥è·¥Ö·¥á ü  ô·¥ÄÍú±…™·¥Ñ)\n"
                "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-"
            )

            await context.bot.send_message(chat_id=chat_id, text=prediction_message)

    except requests.exceptions.RequestException as e:
        logger.error(f"L·ªói khi g·ªçi API: {e}")
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh: {e}")

# --- H√†m x·ª≠ l√Ω l·ªánh /chaymodelbasic ---
async def chay_model_basic(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    global prediction_active, last_known_session_id

    if user_id not in user_subscriptions or user_subscriptions[user_id]["expiry_date"] <= datetime.datetime.now():
        await update.message.reply_text("B·∫°n c·∫ßn k√≠ch ho·∫°t g√≥i ƒë·ªÉ ch·∫°y d·ª± ƒëo√°n. D√πng /key [m√£] ƒë·ªÉ k√≠ch ho·∫°t.")
        return

    existing_jobs = context.job_queue.get_jobs_by_chat_id(update.effective_chat.id)
    for job in existing_jobs:
        if job.name == "prediction_job":
            await update.message.reply_text("D·ª± ƒëo√°n ƒë√£ ƒëang ch·∫°y r·ªìi.")
            return

    prediction_active = True
    chat_id = update.effective_chat.id
    await update.message.reply_text("B·∫Øt ƒë·∫ßu ch·∫°y d·ª± ƒëo√°n (MODEL BASIC). Bot s·∫Ω t·ª± ƒë·ªông g·ª≠i khi c√≥ phi√™n m·ªõi.")

    last_known_session_id = None

    if not hasattr(context, 'job_queue') or context.job_queue is None:
        logger.error("context.job_queue is None. This should not happen in a correctly set up Application.")
        await update.message.reply_text("Bot g·∫∑p l·ªói n·ªôi b·ªô. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá admin.")
        return

    context.job_queue.run_repeating(send_prediction, interval=1, first=0, chat_id=chat_id, name="prediction_job")

# --- H√†m x·ª≠ l√Ω l·ªánh /stop ---
async def stop_prediction(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    global prediction_active, last_known_session_id
    if not prediction_active:
        await update.message.reply_text("D·ª± ƒëo√°n ch∆∞a ƒë∆∞·ª£c ch·∫°y.")
        return

    prediction_active = False
    current_jobs = context.job_queue.get_jobs_by_chat_id(update.effective_chat.id)
    removed_count = 0
    for job in current_jobs:
        if job.name == "prediction_job":
            job.schedule_removal()
            removed_count += 1

    if removed_count > 0:
        await update.message.reply_text("ƒê√£ d·ª´ng d·ª± ƒëo√°n.")
        last_known_session_id = None
    else:
        await update.message.reply_text("Kh√¥ng t√¨m th·∫•y d·ª± ƒëo√°n ƒëang ch·∫°y ƒë·ªÉ d·ª´ng.")

# --- H√†m x·ª≠ l√Ω l·ªánh /key ---
async def activate_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.args:
        await update.message.reply_text("Vui l√≤ng nh·∫≠p m√£ k√≠ch ho·∫°t. V√≠ d·ª•: /key ABC-123-XYZ")
        return

    key_input = context.args[0].upper()
    user_id = update.effective_user.id

    if key_input in active_keys:
        key_info = active_keys[key_input]
        if key_info["user_id"] is None:
            expiry_date = key_info["expiry_date"]
            if expiry_date <= datetime.datetime.now():
                await update.message.reply_text("M√£ k√≠ch ho·∫°t n√†y ƒë√£ h·∫øt h·∫°n. Vui l√≤ng li√™n h·ªá admin.")
                del active_keys[key_input]
                return

            active_keys[key_input]["user_id"] = user_id
            user_subscriptions[user_id] = {"key": key_input, "expiry_date": expiry_date}

            await update.message.reply_text(
                f"üéâ K√≠ch ho·∫°t g√≥i th√†nh c√¥ng!\n"
                f"G√≥i c·ªßa b·∫°n c√≥ hi·ªáu l·ª±c ƒë·∫øn: **{expiry_date.strftime('%H:%M %d/%m/%Y')}**",
                parse_mode=ParseMode.MARKDOWN
            )
            await start(update, context)
        elif key_info["user_id"] == user_id:
            await update.message.reply_text("M√£ n√†y ƒë√£ ƒë∆∞·ª£c b·∫°n s·ª≠ d·ª•ng r·ªìi.")
        else:
            await update.message.reply_text("M√£ n√†y ƒë√£ ƒë∆∞·ª£c ng∆∞·ªùi kh√°c s·ª≠ d·ª•ng.")
    else:
        await update.message.reply_text("M√£ k√≠ch ho·∫°t kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.")

# --- H√†m Admin: /taokey ---
async def create_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    if not context.args:
        await update.message.reply_text("Vui l√≤ng cung c·∫•p th·ªùi h·∫°n key. V√≠ d·ª•: `/taokey 1d`, `/taokey 2w`, `/taokey vinhvien`", parse_mode=ParseMode.MARKDOWN)
        return

    duration_str = context.args[0].lower()
    expiry_date = None
    key = "LW-" + str(uuid.uuid4()).split('-')[0].upper()

    now = datetime.datetime.now()

    if duration_str == "vinhvien":
        expiry_date = now + datetime.timedelta(days=365 * 100)
    else:
        try:
            value = int(duration_str[:-1])
            unit = duration_str[-1]
            if unit == 's':
                expiry_date = now + datetime.timedelta(seconds=value)
            elif unit == 'm':
                expiry_date = now + datetime.timedelta(minutes=value)
            elif unit == 'h':
                expiry_date = now + datetime.timedelta(hours=value)
            elif unit == 'd':
                expiry_date = now + datetime.timedelta(days=value)
            elif unit == 'w':
                expiry_date = now + datetime.timedelta(weeks=value)
            elif unit == 'M':
                expiry_date = now + datetime.timedelta(days=value * 30)
            elif unit == 'y':
                expiry_date = now + datetime.timedelta(days=value * 365)
            else:
                await update.message.reply_text("ƒê·ªãnh d·∫°ng th·ªùi h·∫°n kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `1s, 5m, 2h, 1d, 3w, 1M, 1y, vinhvien`", parse_mode=ParseMode.MARKDOWN)
                return
        except (ValueError, IndexError):
            await update.message.reply_text("ƒê·ªãnh d·∫°ng th·ªùi h·∫°n kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `1s, 5m, 2h, 1d, 3w, 1M, 1y, vinhvien`", parse_mode=ParseMode.MARKDOWN)
            return

    if expiry_date:
        active_keys[key] = {"expiry_date": expiry_date, "user_id": None}
        await update.message.reply_text(
            f"ƒê√£ t·∫°o key: `{key}`\n"
            f"Th·ªùi h·∫°n: {duration_str}\n"
            f"H·∫øt h·∫°n v√†o: {expiry_date.strftime('%H:%M %d/%m/%Y')}",
            parse_mode=ParseMode.MARKDOWN
        )
    else:
        await update.message.reply_text("L·ªói khi t·∫°o key. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë·ªãnh d·∫°ng.")

# --- H√†m Admin: /tbao ---
async def send_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    if not context.args:
        await update.message.reply_text("Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o. V√≠ d·ª•: `/tbao Bot s·∫Ω b·∫£o tr√¨ v√†o 23h`", parse_mode=ParseMode.MARKDOWN)
        return

    message_to_send = "üì¢ **TH√îNG B√ÅO T·ª™ ADMIN** üì¢\n\n" + " ".join(context.args)

    success_count = 0
    fail_count = 0

    for user_id in list(registered_users):
        try:
            await context.bot.send_message(chat_id=user_id, text=message_to_send, parse_mode=ParseMode.MARKDOWN)
            success_count += 1
        except Exception as e:
            logger.error(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o t·ªõi user {user_id}: {e}")
            fail_count += 1

    await update.message.reply_text(f"ƒê√£ g·ª≠i th√¥ng b√°o t·ªõi {success_count} ng∆∞·ªùi d√πng. Th·∫•t b·∫°i: {fail_count}.")

# --- H√†m Admin: /check ---
async def check_performance(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    total_predictions = len(prediction_history)
    correct_predictions = 0
    wrong_predictions = 0

    for record in prediction_history:
        api_result = record.get("ket_qua_api")
        bot_prediction = record.get("du_doan_bot")

        if (api_result == "t" and bot_prediction == "T√†i") or \
           (api_result == "x" and bot_prediction == "X·ªâu"):
            correct_predictions += 1
        elif api_result and bot_prediction:
            wrong_predictions += 1

    if total_predictions == 0:
        response_message = "Ch∆∞a c√≥ d·ªØ li·ªáu d·ª± ƒëo√°n n√†o ƒë·ªÉ ki·ªÉm tra."
    else:
        accuracy = (correct_predictions / total_predictions) * 100 if total_predictions > 0 else 0
        response_message = (
            "üìä **TH·ªêNG K√ä D·ª∞ ƒêO√ÅN** üìä\n\n"
            f"T·ªïng s·ªë phi√™n d·ª± ƒëo√°n: {total_predictions}\n"
            f"S·ªë phi√™n d·ª± ƒëo√°n ƒë√∫ng: {correct_predictions}\n"
            f"S·ªë phi√™n d·ª± ƒëo√°n sai: {wrong_predictions}\n"
            f"T·ª∑ l·ªá ch√≠nh x√°c: {accuracy:.2f}%\n\n"
            "*(D·ªØ li·ªáu n√†y ch·ªâ l∆∞u trong b·ªô nh·ªõ v√† s·∫Ω reset khi bot kh·ªüi ƒë·ªông l·∫°i)*"
        )
    await update.message.reply_text(response_message, parse_mode=ParseMode.MARKDOWN)

# --- H√†m x·ª≠ l√Ω l·ªánh /admin (ch·ªâ admin m·ªõi d√πng ƒë∆∞·ª£c) ---
async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id

    if user_id == ADMIN_ID:
        admin_help_message = (
            "üõ†Ô∏è **L·ªánh d√†nh cho Admin:**\n"
            "`/taokey [th·ªùi_h·∫°n]` - T·∫°o key k√≠ch ho·∫°t g√≥i.\n"
            "   - Th·ªùi h·∫°n: `Xs` (gi√¢y), `Xm` (ph√∫t), `Xh` (gi·ªù), `Xd` (ng√†y), `Xw` (tu·∫ßn), `XM` (th√°ng), `Xy` (nƒÉm), `vinhvien`.\n"
            "   - V√≠ d·ª•: `/taokey 3d` (3 ng√†y), `/taokey 1y` (1 nƒÉm), `/taokey vinhvien`.\n"
            "`/tbao [n·ªôi_dung]` - G·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng.\n"
            "   - V√≠ d·ª•: `/tbao Bot s·∫Ω c·∫≠p nh·∫≠t v√†o l√∫c 20h h√¥m nay.`\n"
            "`/check` - Ki·ªÉm tra hi·ªáu su·∫•t d·ª± ƒëo√°n c·ªßa bot.\n"
            "**L∆∞u √Ω:** D·ªØ li·ªáu key v√† l·ªãch s·ª≠ d·ª± ƒëo√°n hi·ªán t·∫°i ch·ªâ l∆∞u t·∫°m th·ªùi trong b·ªô nh·ªõ v√† s·∫Ω m·∫•t khi bot kh·ªüi ƒë·ªông l·∫°i. N√™n d√πng c∆° s·ªü d·ªØ li·ªáu cho b·∫£n ch√≠nh th·ª©c."
        )
        await update.message.reply_text(admin_help_message, parse_mode=ParseMode.MARKDOWN)
    else:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")

def main() -> None:
    """Kh·ªüi ch·∫°y bot."""
    application = Application.builder().token(BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("chaymodelbasic", chay_model_basic))
    application.add_handler(CommandHandler("stop", stop_prediction))
    application.add_handler(CommandHandler("key", activate_key))

    application.add_handler(CommandHandler("admin", admin_command))
    application.add_handler(CommandHandler("taokey", create_key))
    application.add_handler(CommandHandler("tbao", send_broadcast))
    application.add_handler(CommandHandler("check", check_performance))

    logger.info(f"Bot ƒëang ch·∫°y v·ªõi webhooks tr√™n c·ªïng {WEB_SERVER_PORT}")
    application.run_webhook(
        listen="0.0.0.0",
        port=WEB_SERVER_PORT,
        url_path=WEBHOOK_URL_PATH,
        webhook_url=WEBHOOK_URL
    )

if __name__ == "__main__":
    main()
