import telebot
import requests
import time
import json
import os
import random
import string
from datetime import datetime, timedelta
from threading import Thread, Event, Lock

from flask import Flask, request

# --- C·∫•u h√¨nh Bot ---
BOT_TOKEN = "8137068939:AAG19xO92yXsz_d9vz_m2aJW2Wh8JZnvSPQ"
ADMIN_IDS = [6915752059]

DATA_FILE = 'user_data.json'
CODES_FILE = 'codes.json'
PREDICTION_STATS_FILE = 'prediction_stats.json'

# --- Kh·ªüi t·∫°o Flask App v√† Telegram Bot ---
app = Flask(__name__)
bot = telebot.TeleBot(BOT_TOKEN, threaded=False) 

# Global flags v√† objects
bot_enabled = True
prediction_stop_event = Event() 
bot_initialized = False 
bot_init_lock = Lock() 

# Global data structures
user_data = {}
GENERATED_CODES = {} 
last_prediction_phien = None 
prediction_stats = {"correct": 0, "total": 0} 

# --- Qu·∫£n l√Ω d·ªØ li·ªáu ng∆∞·ªùi d√πng v√† code ---
def load_user_data():
    global user_data
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, 'r') as f:
            try:
                user_data = json.load(f)
                print(f"[DEBUG] T·∫£i d·ªØ li·ªáu ng∆∞·ªùi d√πng: {user_data}")
            except json.JSONDecodeError:
                print(f"[ERROR] L·ªói ƒë·ªçc {DATA_FILE}. Kh·ªüi t·∫°o l·∫°i d·ªØ li·ªáu ng∆∞·ªùi d√πng.")
                user_data = {}
    else:
        print(f"[DEBUG] File {DATA_FILE} kh√¥ng t·ªìn t·∫°i. Kh·ªüi t·∫°o d·ªØ li·ªáu ng∆∞·ªùi d√πng r·ªóng.")
        user_data = {}
    print(f"Loaded {len(user_data)} user records from {DATA_FILE}")

def save_user_data(data):
    with open(DATA_FILE, 'w') as f:
        json.dump(data, f, indent=4)
    print(f"[DEBUG] ƒê√£ l∆∞u {len(data)} b·∫£n ghi ng∆∞·ªùi d√πng v√†o {DATA_FILE}")

def load_codes():
    global GENERATED_CODES
    if os.path.exists(CODES_FILE):
        with open(CODES_FILE, 'r') as f:
            try:
                GENERATED_CODES = json.load(f)
                print(f"[DEBUG] T·∫£i d·ªØ li·ªáu codes: {GENERATED_CODES}")
            except json.JSONDecodeError:
                print(f"[ERROR] L·ªói ƒë·ªçc {CODES_FILE}. Kh·ªüi t·∫°o l·∫°i m√£ code.")
                GENERATED_CODES = {}
    else:
        print(f"[DEBUG] File {CODES_FILE} kh√¥ng t·ªìn t·∫°i. Kh·ªüi t·∫°o m√£ code r·ªóng.")
        GENERATED_CODES = {}
    print(f"Loaded {len(GENERATED_CODES)} codes from {CODES_FILE}")

def save_codes():
    with open(CODES_FILE, 'w') as f:
        json.dump(GENERATED_CODES, f, indent=4)
    print(f"[DEBUG] ƒê√£ l∆∞u {len(GENERATED_CODES)} codes v√†o {CODES_FILE}")

def load_prediction_stats():
    global prediction_stats
    if os.path.exists(PREDICTION_STATS_FILE):
        with open(PREDICTION_STATS_FILE, 'r') as f:
            try:
                prediction_stats = json.load(f)
            except json.JSONDecodeError:
                print(f"[ERROR] L·ªói ƒë·ªçc {PREDICTION_STATS_FILE}. Kh·ªüi t·∫°o l·∫°i th·ªëng k√™ d·ª± ƒëo√°n.")
                prediction_stats = {"correct": 0, "total": 0}
    else:
        print(f"[DEBUG] File {PREDICTION_STATS_FILE} kh√¥ng t·ªìn t·∫°i. Kh·ªüi t·∫°o th·ªëng k√™ d·ª± ƒëo√°n r·ªóng.")
        prediction_stats = {"correct": 0, "total": 0}
    print(f"Loaded prediction stats: Correct {prediction_stats['correct']}, Total {prediction_stats['total']}")

def save_prediction_stats():
    with open(PREDICTION_STATS_FILE, 'w') as f:
        json.dump(prediction_stats, f, indent=4)
    print(f"[DEBUG] ƒê√£ l∆∞u th·ªëng k√™ d·ª± ƒëo√°n: Correct {prediction_stats['correct']}, Total {prediction_stats['total']}")

def is_admin(user_id):
    return user_id in ADMIN_IDS

def check_subscription(user_id):
    user_id_str = str(user_id)
    if is_admin(user_id):
        return True, "B·∫°n l√† Admin, quy·ªÅn truy c·∫≠p vƒ©nh vi·ªÖn."

    if user_id_str not in user_data or user_data[user_id_str].get('expiry_date') is None:
        return False, "‚ö†Ô∏è B·∫°n ch∆∞a k√≠ch ho·∫°t g√≥i ho·∫∑c g√≥i ƒë√£ h·∫øt h·∫°n."

    expiry_date_str = user_data[user_id_str]['expiry_date']
    if expiry_date_str == "Vƒ©nh vi·ªÖn":
        return True, "‚úÖ G√≥i c·ªßa b·∫°n l√† vƒ©nh vi·ªÖn."

    try:
        expiry_date = datetime.strptime(expiry_date_str, '%Y-%m-%d %H:%M:%S')
    except ValueError:
        print(f"[ERROR] ƒê·ªãnh d·∫°ng ng√†y h·∫øt h·∫°n kh√¥ng h·ª£p l·ªá cho user {user_id_str}: {expiry_date_str}")
        return False, "‚ö†Ô∏è ƒê·ªãnh d·∫°ng ng√†y h·∫øt h·∫°n kh√¥ng h·ª£p l·ªá."

    if datetime.now() < expiry_date:
        remaining_time = expiry_date - datetime.now()
        days = remaining_time.days
        hours = remaining_time.seconds // 3600
        minutes = (remaining_time.seconds % 3600) // 60
        return True, f"‚úÖ G√≥i c·ªßa b·∫°n c√≤n h·∫°n ƒë·∫øn: `{expiry_date_str}` ({days} ng√†y {hours} gi·ªù {minutes} ph√∫t)."
    else:
        return False, "‚ùå G√≥i c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n."

def get_subscription_status(user_id_str):
    if user_id_str not in user_data or user_data[user_id_str].get('expiry_date') is None:
        return "Ch∆∞a k√≠ch ho·∫°t", "Ch∆∞a k√≠ch ho·∫°t"
    
    expiry_date_str = user_data[user_id_str]['expiry_date']
    
    if expiry_date_str == "Vƒ©nh vi·ªÖn":
        return "Vƒ©nh vi·ªÖn", "Vƒ©nh vi·ªÖn"

    try:
        expiry_date = datetime.strptime(expiry_date_str, '%Y-%m-%d %H:%M:%S')
    except ValueError:
        print(f"[ERROR] ƒê·ªãnh d·∫°ng ng√†y h·∫øt h·∫°n kh√¥ng h·ª£p l·ªá cho user {user_id_str}: {expiry_date_str}")
        return "L·ªói ƒë·ªãnh d·∫°ng", "L·ªói ƒë·ªãnh d·∫°ng"

    if datetime.now() < expiry_date:
        return "ƒê√£ k√≠ch ho·∫°t", expiry_date_str
    else:
        return "ƒê√£ h·∫øt h·∫°n", expiry_date_str

# --- L·∫•y d·ªØ li·ªáu t·ª´ API m·ªõi ---
def lay_du_lieu_tu_api_moi():
    try:
        print("[DEBUG] ƒêang c·ªë g·∫Øng l·∫•y d·ªØ li·ªáu t·ª´ API...")
        response = requests.get("https://apiluck2.onrender.com/predict")
        response.raise_for_status() 
        data = response.json()
        print(f"[DEBUG] ƒê√£ nh·∫≠n d·ªØ li·ªáu t·ª´ API: {data}")
        return data
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] L·ªói khi l·∫•y d·ªØ li·ªáu t·ª´ API: {e}")
        return None
    except json.JSONDecodeError:
        print("[ERROR] L·ªói gi·∫£i m√£ JSON t·ª´ API. Ph·∫£n h·ªìi kh√¥ng ph·∫£i JSON h·ª£p l·ªá.")
        return None

# --- Logic ch√≠nh c·ªßa Bot d·ª± ƒëo√°n (ch·∫°y trong lu·ªìng ri√™ng) ---
def prediction_loop(stop_event: Event):
    global last_prediction_phien, prediction_stats
    print("[INFO] Prediction loop started.")
    
    # Kh·ªüi t·∫°o last_prediction_phien t·ª´ API khi kh·ªüi ƒë·ªông
    initial_api_data = lay_du_lieu_tu_api_moi()
    if initial_api_data:
        last_prediction_phien = initial_api_data.get("phien_du_doan")
        print(f"[INFO] Kh·ªüi t·∫°o last_prediction_phien: {last_prediction_phien}")
    else:
        print("[WARNING] Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu API ban ƒë·∫ßu ƒë·ªÉ kh·ªüi t·∫°o last_prediction_phien.")

    while not stop_event.is_set():
        if not bot_enabled:
            print("[DEBUG] Bot ƒëang b·ªã t·∫Øt, ch·ªù 10 gi√¢y.")
            time.sleep(10) 
            continue

        api_data = lay_du_lieu_tu_api_moi()
        if not api_data:
            print("[WARNING] Kh√¥ng c√≥ d·ªØ li·ªáu API, ch·ªù 5 gi√¢y.")
            time.sleep(5)
            continue

        current_phien_api = api_data.get("Phien_moi")
        phien_du_doan_api = api_data.get("phien_du_doan")

        if not all([current_phien_api, phien_du_doan_api]):
            print(f"[WARNING] D·ªØ li·ªáu API kh√¥ng ƒë·∫ßy ƒë·ªß: Phien_moi={current_phien_api}, phien_du_doan={phien_du_doan_api}. B·ªè qua phi√™n n√†y.")
            time.sleep(5)
            continue
        
        print(f"[DEBUG] Phi√™n API hi·ªán t·∫°i: {current_phien_api}, Phi√™n d·ª± ƒëo√°n API: {phien_du_doan_api}, last_prediction_phien ƒë√£ l∆∞u: {last_prediction_phien}")

        # So s√°nh phi√™n d·ª± ƒëo√°n t·ª´ API v·ªõi phi√™n cu·ªëi c√πng ƒë√£ g·ª≠i
        if phien_du_doan_api != last_prediction_phien:
            print(f"[INFO] Ph√°t hi·ªán phi√™n d·ª± ƒëo√°n m·ªõi: {phien_du_doan_api}. B·∫Øt ƒë·∫ßu x·ª≠ l√Ω.")
            
            ket_qua_hien_tai_raw = api_data.get("matches")[0].upper() if api_data.get("matches") else "?"
            if ket_qua_hien_tai_raw == "T":
                ket_qua_text = "T√ÄI"
            elif ket_qua_hien_tai_raw == "X":
                ket_qua_text = "X·ªàU"
            else:
                ket_qua_text = "Kh√¥ng r√µ"
            
            # API kh√¥ng tr·∫£ v·ªÅ t·ªïng 3 x√∫c x·∫Øc c·ª• th·ªÉ. D√πng t·∫°m "T·ªïng: XX" n·∫øu c√≥ th·ªÉ suy lu·∫≠n ho·∫∑c b·ªè qua.
            tong_ket_qua_hien_tai = "??" 

            pattern = api_data.get("pattern", "Kh√¥ng c√≥")
            du_doan_ket_qua = api_data.get("du_doan", "Kh√¥ng r√µ")
            
            prediction_message = (
                f"ü§ñ  ü·¥ú·¥Ñ·¥ã è·¥°…™…¥\n"
                f"üéØ ·¥ò ú…™·¥áÃÇ…¥ {current_phien_api}\n"
                f"üé≤ ·¥ã·¥áÃÇÃÅ·¥õ «´·¥ú·¥ÄÃâ : {ket_qua_text} {tong_ket_qua_hien_tai}\n"
                f"üß© ·¥ò·¥Ä·¥õ·¥õ·¥á Ä…¥ : {pattern.upper()}\n"
                f"üéÆ  ·¥ò ú…™·¥áÃÇ…¥ {phien_du_doan_api} : {du_doan_ket_qua} (·¥ç·¥è·¥Ö·¥á ü  ô·¥ÄÍú±…™·¥Ñ)\n"
                "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-"
            )

            # C·∫≠p nh·∫≠t th·ªëng k√™ d·ª± ƒëo√°n
            if du_doan_ket_qua.lower().strip() == ket_qua_text.lower().strip(): # So s√°nh d·ª± ƒëo√°n v·ªõi k·∫øt qu·∫£ th·ª±c t·∫ø
                prediction_stats['correct'] += 1
                print(f"[DEBUG] D·ª± ƒëo√°n ƒë√∫ng: {du_doan_ket_qua} == {ket_qua_text}")
            else:
                print(f"[DEBUG] D·ª± ƒëo√°n sai: {du_doan_ket_qua} != {ket_qua_text}")
            prediction_stats['total'] += 1
            save_prediction_stats()

            # G·ª≠i tin nh·∫Øn cho ng∆∞·ªùi d√πng
            for user_id_str, user_info in list(user_data.items()):
                user_id = int(user_id_str)
                is_sub, sub_message = check_subscription(user_id)
                
                if is_sub and user_info.get('running_prediction'):
                    try:
                        print(f"[DEBUG] G·ª≠i tin nh·∫Øn cho user {user_id}...")
                        bot.send_message(user_id, prediction_message)
                        print(f"[INFO] ƒê√£ g·ª≠i tin nh·∫Øn cho user {user_id}.")
                    except telebot.apihelper.ApiTelegramException as e:
                        if "bot was blocked by the user" in str(e) or "user is deactivated" in str(e):
                            print(f"[WARNING] Ng∆∞·ªùi d√πng {user_id} ƒë√£ ch·∫∑n bot ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a.")
                            # Optional: remove user from user_data if blocked permanently
                        else:
                            print(f"[ERROR] L·ªói g·ª≠i tin nh·∫Øn cho user {user_id}: {e}")
                    except Exception as e:
                        print(f"[ERROR] L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i tin nh·∫Øn cho user {user_id}: {e}")
                elif not is_sub:
                    print(f"[DEBUG] B·ªè qua user {user_id}: G√≥i ƒë√£ h·∫øt h·∫°n ho·∫∑c ch∆∞a k√≠ch ho·∫°t.")
                else: # user_info.get('running_prediction') is False
                    print(f"[DEBUG] B·ªè qua user {user_id}: Ng∆∞·ªùi d√πng ch∆∞a b·∫≠t d·ª± ƒëo√°n.")
            
            print(f"[INFO] K·∫øt th√∫c x·ª≠ l√Ω phi√™n {phien_du_doan_api}. C·∫≠p nh·∫≠t last_prediction_phien.")
            last_prediction_phien = phien_du_doan_api
        else:
            print(f"[DEBUG] Phi√™n {phien_du_doan_api} kh√¥ng ph·∫£i phi√™n m·ªõi. Kh√¥ng g·ª≠i tin nh·∫Øn.")

        time.sleep(5) 
    print("[INFO] Prediction loop stopped.")

# --- X·ª≠ l√Ω l·ªánh Telegram ---

@bot.message_handler(commands=['start'])
def send_welcome(message):
    user_id = str(message.chat.id)
    username = message.from_user.first_name or message.from_user.username
    
    if user_id not in user_data:
        user_data[user_id] = {
            'username': username,
            'expiry_date': None,
            'running_prediction': False 
        }
        save_user_data(user_data)
        print(f"[INFO] ƒê√£ th√™m ng∆∞·ªùi d√πng m·ªõi: {user_id} - {username}")
    else:
        if user_data[user_id].get('username') != username:
            user_data[user_id]['username'] = username 
            save_user_data(user_data)
            print(f"[INFO] ƒê√£ c·∫≠p nh·∫≠t username cho ng∆∞·ªùi d√πng: {user_id} - {username}")


    current_package, expiry_status = get_subscription_status(user_id)

    welcome_message = (
        f"üåü CH√ÄO M·ª™NG {username} üåü\n"
        "üéâ Ch√†o m·ª´ng ƒë·∫øn v·ªõi HeHe Bot üéâ\n"
        f"üì¶ G√≥i hi·ªán t·∫°i: {current_package}\n"
        f"‚è∞ H·∫øt h·∫°n: {expiry_status}\n"
        "üí° D√πng /help ƒë·ªÉ xem c√°c l·ªánh"
    )
    bot.reply_to(message, welcome_message)
    print(f"[INFO] ƒê√£ g·ª≠i tin nh·∫Øn ch√†o m·ª´ng cho {user_id}")

@bot.message_handler(commands=['help'])
def show_help(message):
    user_id_str = str(message.chat.id)
    current_package, expiry_status = get_subscription_status(user_id_str)

    help_text = (
        f"üì¶ G√≥i hi·ªán t·∫°i: {current_package}\n"
        "üî• C√°c l·ªánh h·ªó tr·ª£:\n"
        "‚úÖ `/start` - ƒêƒÉng k√Ω v√† b·∫Øt ƒë·∫ßu\n"
        "üîë `/key [m√£]` - K√≠ch ho·∫°t g√≥i\n"
        "üéÆ `/chaymodelbasic` - Ch·∫°y d·ª± ƒëo√°n  (LUCK)\n"
        "üõë `/stop` - D·ª´ng d·ª± ƒëo√°n\n"
        "üõ†Ô∏è `/admin` - L·ªánh d√†nh cho admin\n"
        "üì¨ Li√™n h·ªá:\n"
        "üë§ Admin: t.me/heheviptool\n"
        "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî"
    )
    bot.reply_to(message, help_text, parse_mode='Markdown')
    print(f"[INFO] ƒê√£ g·ª≠i tin nh·∫Øn tr·ª£ gi√∫p cho {user_id_str}")

@bot.message_handler(commands=['key'])
def use_code(message):
    code_str = telebot.util.extract_arguments(message.text)
    user_id = str(message.chat.id)
    print(f"[INFO] User {user_id} d√πng l·ªánh /key v·ªõi code: {code_str}")

    if not code_str:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p m√£ code. V√≠ d·ª•: `/key ABCXYZ`", parse_mode='Markdown')
        return
    
    if code_str not in GENERATED_CODES:
        bot.reply_to(message, "‚ùå M√£ code kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n.")
        return

    code_info = GENERATED_CODES[code_str]
    if code_info.get('used_by') is not None:
        bot.reply_to(message, "‚ùå M√£ code n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªìi.")
        return

    # Apply extension
    current_expiry_str = user_data.get(user_id, {}).get('expiry_date')
    
    if code_info['type'] == 'vƒ©nh_vi·ªÖn':
        new_expiry_date_str = "Vƒ©nh vi·ªÖn"
        value_display = "" 
        unit_display = "vƒ©nh vi·ªÖn"
    else:
        if current_expiry_str and current_expiry_str != "Vƒ©nh vi·ªÖn":
            try:
                current_expiry_date = datetime.strptime(current_expiry_str, '%Y-%m-%d %H:%M:%S')
            except ValueError:
                print(f"[ERROR] ƒê·ªãnh d·∫°ng ng√†y h·∫øt h·∫°n c≈© kh√¥ng h·ª£p l·ªá cho user {user_id}: {current_expiry_str}. B·∫Øt ƒë·∫ßu t·ª´ b√¢y gi·ªù.")
                current_expiry_date = datetime.now() # Reset n·∫øu ƒë·ªãnh d·∫°ng c≈© l·ªói
            
            if datetime.now() > current_expiry_date:
                new_expiry_date = datetime.now()
            else:
                new_expiry_date = current_expiry_date
        else:
            new_expiry_date = datetime.now() 

        value = code_info['value']
        unit = code_info['type']
        value_display = value
        unit_display = unit

        if unit == 'ph√∫t':
            new_expiry_date += timedelta(minutes=value)
        elif unit == 'gi·ªù':
            new_expiry_date += timedelta(hours=value)
        elif unit == 'ng√†y':
            new_expiry_date += timedelta(days=value)
        elif unit == 'tu·∫ßn':
            new_expiry_date += timedelta(weeks=value)
        elif unit == 'th√°ng':
            new_expiry_date += timedelta(days=value*30) 
        
        new_expiry_date_str = new_expiry_date.strftime('%Y-%m-%d %H:%M:%S')
    
    user_data.setdefault(user_id, {})['expiry_date'] = new_expiry_date_str
    user_data[user_id]['username'] = message.from_user.first_name or message.from_user.username
    
    GENERATED_CODES[code_str]['used_by'] = user_id
    GENERATED_CODES[code_str]['used_time'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    save_user_data(user_data)
    save_codes()

    bot.reply_to(message, 
                 f"üéâ B·∫°n ƒë√£ ƒë·ªïi m√£ code th√†nh c√¥ng! G√≥i c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m **{value_display} {unit_display}**.\n"
                 f"Ng√†y h·∫øt h·∫°n m·ªõi: `{user_data[user_id]['expiry_date']}`", 
                 parse_mode='Markdown')
    print(f"[INFO] User {user_id} ƒë√£ k√≠ch ho·∫°t code {code_str}. H·∫øt h·∫°n m·ªõi: {new_expiry_date_str}")

@bot.message_handler(commands=['chaymodelbasic'])
def start_prediction_command(message):
    user_id = str(message.chat.id)
    print(f"[INFO] User {user_id} d√πng l·ªánh /chaymodelbasic")
    is_sub, sub_message = check_subscription(int(user_id))
    
    if not is_sub:
        bot.reply_to(message, sub_message + "\nVui l√≤ng li√™n h·ªá Admin t.me/heheviptool ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.", parse_mode='Markdown')
        print(f"[INFO] User {user_id} kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ ch·∫°y d·ª± ƒëo√°n: {sub_message}")
        return
    
    if not bot_enabled:
        bot.reply_to(message, f"‚ùå Bot d·ª± ƒëo√°n hi·ªán ƒëang t·∫°m d·ª´ng b·ªüi Admin. Vui l√≤ng th·ª≠ l·∫°i sau.", parse_mode='Markdown')
        print(f"[INFO] User {user_id} kh√¥ng th·ªÉ ch·∫°y d·ª± ƒëo√°n v√¨ bot b·ªã t·∫Øt.")
        return

    user_data[user_id]['running_prediction'] = True
    save_user_data(user_data)
    bot.reply_to(message, "‚úÖ B·∫°n ƒë√£ b·∫≠t ch·∫ø ƒë·ªô nh·∫≠n d·ª± ƒëo√°n t·ª´ bot. Bot s·∫Ω t·ª± ƒë·ªông g·ª≠i d·ª± ƒëo√°n c√°c phi√™n m·ªõi nh·∫•t t·∫°i ƒë√¢y.")
    print(f"[INFO] User {user_id} ƒë√£ b·∫≠t nh·∫≠n d·ª± ƒëo√°n.")

@bot.message_handler(commands=['stop'])
def stop_prediction_command(message):
    user_id = str(message.chat.id)
    user_data[user_id]['running_prediction'] = False
    save_user_data(user_data)
    bot.reply_to(message, "‚úÖ B·∫°n ƒë√£ d·ª´ng nh·∫≠n d·ª± ƒëo√°n t·ª´ bot.")
    print(f"[INFO] User {user_id} ƒë√£ d·ª´ng nh·∫≠n d·ª± ƒëo√°n.")

# --- L·ªánh Admin ---
@bot.message_handler(commands=['admin'])
def admin_menu(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        print(f"[WARNING] User {message.chat.id} kh√¥ng c√≥ quy·ªÅn d√πng l·ªánh /admin.")
        return
    
    admin_help_text = (
        "üëë **L·ªÜNH ADMIN** üëë\n\n"
        "üîπ `/full <id>`: Xem th√¥ng tin ng∆∞·ªùi d√πng (ƒë·ªÉ tr·ªëng ID ƒë·ªÉ xem c·ªßa b·∫°n).\n"
        "üîπ `/giahan <id> <s·ªë ng√†y/gi·ªù/tu·∫ßn/th√°ng/vƒ©nh_vi·ªÖn>`: Gia h·∫°n t√†i kho·∫£n. VD: `/giahan 12345 1 ng√†y`, `/giahan 67890 vƒ©nh_vi·ªÖn`.\n"
        "üîπ `/tb <n·ªôi dung>`: G·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng.\n"
        "üîπ `/tatbot`: T·∫Øt m·ªçi ho·∫°t ƒë·ªông d·ª± ƒëo√°n c·ªßa bot.\n"
        "üîπ `/mokbot`: M·ªü l·∫°i ho·∫°t ƒë·ªông d·ª± ƒëo√°n c·ªßa bot.\n"
        "üîπ `/taokey <gi√° tr·ªã> <ph√∫t/gi·ªù/ng√†y/tu·∫ßn/th√°ng/vƒ©nh_vi·ªÖn> <s·ªë l∆∞·ª£ng>`: T·∫°o m√£ key. VD: `/taokey 1 ng√†y 5`, `/taokey 1 vƒ©nh_vi·ªÖn 1`.\n"
        "üîπ `/check`: Ki·ªÉm tra th·ªëng k√™ d·ª± ƒëo√°n c·ªßa bot.\n"
        "üîπ `/thongke` : Th·ªëng k√™ s·ªë l∆∞·ª£ng ng∆∞·ªùi d√πng v√† key ƒë√£ d√πng."
    )
    bot.reply_to(message, admin_help_text, parse_mode='Markdown')
    print(f"[INFO] Admin {message.chat.id} y√™u c·∫ßu menu admin.")

@bot.message_handler(commands=['full'])
def get_user_info(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    target_user_id_str = str(message.chat.id)
    if args and args[0].isdigit():
        target_user_id_str = args[0]
    
    if target_user_id_str not in user_data:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y th√¥ng tin cho ng∆∞·ªùi d√πng ID `{target_user_id_str}`.")
        return

    user_info = user_data[target_user_id_str]
    expiry_date_str = user_info.get('expiry_date', 'Ch∆∞a k√≠ch ho·∫°t')
    username = user_info.get('username', 'Kh√¥ng r√µ')
    running_pred_status = "ƒêang ch·∫°y" if user_info.get('running_prediction') else "ƒê√£ d·ª´ng"

    info_text = (
        f"**TH√îNG TIN NG∆Ø·ªúI D√ôNG**\n"
        f"**ID:** `{target_user_id_str}`\n"
        f"**T√™n:** @{username}\n"
        f"**Ng√†y h·∫øt h·∫°n:** `{expiry_date_str}`\n"
        f"**Tr·∫°ng th√°i nh·∫≠n d·ª± ƒëo√°n:** {running_pred_status}"
    )
    bot.reply_to(message, info_text, parse_mode='Markdown')
    print(f"[INFO] Admin {message.chat.id} y√™u c·∫ßu th√¥ng tin user: {target_user_id_str}")

@bot.message_handler(commands=['giahan'])
def extend_subscription(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not (len(args) == 3 and args[1].isdigit() and args[2].lower() in ['ph√∫t', 'gi·ªù', 'ng√†y', 'tu·∫ßn', 'th√°ng']) and \
       not (len(args) == 2 and args[1].lower() == 'vƒ©nh_vi·ªÖn' and args[0].isdigit()):
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/giahan <id_nguoi_dung> <s·ªë_l∆∞·ª£ng> <ph√∫t/gi·ªù/ng√†y/tu·∫ßn/th√°ng>` ho·∫∑c `/giahan <id_nguoi_dung> vƒ©nh_vi·ªÖn`.\n"
                              "V√≠ d·ª•: `/giahan 12345 1 ng√†y` ho·∫∑c `/giahan 67890 vƒ©nh_vi·ªÖn`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]

    if target_user_id_str not in user_data:
        user_data[target_user_id_str] = {
            'username': "UnknownUser",
            'expiry_date': None,
            'running_prediction': False
        }
        bot.send_message(message.chat.id, f"ƒê√£ t·∫°o t√†i kho·∫£n m·ªõi cho user ID `{target_user_id_str}`.")
        print(f"[INFO] Admin {message.chat.id} t·∫°o t√†i kho·∫£n m·ªõi cho {target_user_id_str}.")

    if args[1].lower() == 'vƒ©nh_vi·ªÖn':
        new_expiry_date_str = "Vƒ©nh vi·ªÖn"
        value_display = ""
        unit_display = "vƒ©nh vi·ªÖn"
    else:
        value = int(args[1])
        unit = args[2].lower()
        value_display = value
        unit_display = unit

        current_expiry_str = user_data[target_user_id_str].get('expiry_date')
        if current_expiry_str and current_expiry_str != "Vƒ©nh vi·ªÖn":
            try:
                current_expiry_date = datetime.strptime(current_expiry_str, '%Y-%m-%d %H:%M:%S')
            except ValueError:
                print(f"[ERROR] ƒê·ªãnh d·∫°ng ng√†y h·∫øt h·∫°n c≈© kh√¥ng h·ª£p l·ªá cho user {target_user_id_str}: {current_expiry_str}. B·∫Øt ƒë·∫ßu t·ª´ b√¢y gi·ªù.")
                current_expiry_date = datetime.now()
            if datetime.now() > current_expiry_date:
                new_expiry_date = datetime.now()
            else:
                new_expiry_date = current_expiry_date
        else:
            new_expiry_date = datetime.now() 

        if unit == 'ph√∫t':
            new_expiry_date += timedelta(minutes=value)
        elif unit == 'gi·ªù':
            new_expiry_date += timedelta(hours=value)
        elif unit == 'ng√†y':
            new_expiry_date += timedelta(days=value)
        elif unit == 'tu·∫ßn':
            new_expiry_date += timedelta(weeks=value)
        elif unit == 'th√°ng':
            new_expiry_date += timedelta(days=value*30) 
        
        new_expiry_date_str = new_expiry_date.strftime('%Y-%m-%d %H:%M:%S')
    
    user_data[target_user_id_str]['expiry_date'] = new_expiry_date_str
    save_user_data(user_data)
    
    bot.reply_to(message, 
                 f"ƒê√£ gia h·∫°n th√†nh c√¥ng cho user ID `{target_user_id_str}` th√™m **{value_display} {unit_display}**.\n"
                 f"Ng√†y h·∫øt h·∫°n m·ªõi: `{user_data[target_user_id_str]['expiry_date']}`",
                 parse_mode='Markdown')
    print(f"[INFO] Admin {message.chat.id} gia h·∫°n cho user {target_user_id_str} th√™m {value_display} {unit_display}. H·∫øt h·∫°n m·ªõi: {new_expiry_date_str}")
    
    try:
        bot.send_message(int(target_user_id_str), 
                         f"üéâ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m **{value_display} {unit_display}** b·ªüi Admin!\n"
                         f"Ng√†y h·∫øt h·∫°n m·ªõi c·ªßa b·∫°n l√†: `{user_data[target_user_id_str]['expiry_date']}`",
                         parse_mode='Markdown')
        print(f"[INFO] ƒê√£ th√¥ng b√°o gia h·∫°n cho user {target_user_id_str}.")
    except telebot.apihelper.ApiTelegramException as e:
        if "bot was blocked by the user" in str(e):
            print(f"[WARNING] Kh√¥ng th·ªÉ th√¥ng b√°o gia h·∫°n cho user {target_user_id_str}: ng∆∞·ªùi d√πng ƒë√£ ch·∫∑n bot.")
        else:
            print(f"[ERROR] Kh√¥ng th·ªÉ th√¥ng b√°o gia h·∫°n cho user {target_user_id_str}: {e}")

@bot.message_handler(commands=['tb'])
def send_broadcast(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    broadcast_text = telebot.util.extract_arguments(message.text)
    if not broadcast_text:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o. V√≠ d·ª•: `/tb Bot s·∫Ω b·∫£o tr√¨ v√†o 2h s√°ng mai.`", parse_mode='Markdown')
        return
    
    success_count = 0
    fail_count = 0
    print(f"[INFO] Admin {message.chat.id} g·ª≠i th√¥ng b√°o Broadcast: {broadcast_text}")
    for user_id_str in list(user_data.keys()):
        try:
            bot.send_message(int(user_id_str), f"üì¢ **TH√îNG B√ÅO T·ª™ ADMIN** üì¢\n\n{broadcast_text}", parse_mode='Markdown')
            success_count += 1
            time.sleep(0.1) 
        except telebot.apihelper.ApiTelegramException as e:
            fail_count += 1
            if "bot was blocked by the user" in str(e) or "user is deactivated" in str(e):
                print(f"[WARNING] Ng∆∞·ªùi d√πng {user_id_str} ƒë√£ ch·∫∑n bot ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a khi g·ª≠i broadcast.")
            else:
                print(f"[ERROR] L·ªói kh√¥ng g·ª≠i ƒë∆∞·ª£c th√¥ng b√°o broadcast cho user {user_id_str}: {e}")
        except Exception as e:
            print(f"[ERROR] L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i th√¥ng b√°o broadcast cho user {user_id_str}: {e}")
            fail_count += 1
                
    bot.reply_to(message, f"ƒê√£ g·ª≠i th√¥ng b√°o ƒë·∫øn {success_count} ng∆∞·ªùi d√πng. Th·∫•t b·∫°i: {fail_count}.")
    save_user_data(user_data)

@bot.message_handler(commands=['tatbot'])
def disable_bot_command(message):
    global bot_enabled
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    if not bot_enabled:
        bot.reply_to(message, "Bot d·ª± ƒëo√°n ƒë√£ v√† ƒëang t·∫Øt r·ªìi.")
        return

    bot_enabled = False
    bot.reply_to(message, f"‚úÖ Bot d·ª± ƒëo√°n ƒë√£ ƒë∆∞·ª£c t·∫Øt b·ªüi Admin.")
    print(f"[INFO] Admin {message.chat.id} ƒë√£ t·∫Øt bot.")
    
@bot.message_handler(commands=['mokbot'])
def enable_bot_command(message):
    global bot_enabled
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    if bot_enabled:
        bot.reply_to(message, "Bot d·ª± ƒëo√°n ƒë√£ v√† ƒëang ho·∫°t ƒë·ªông r·ªìi.")
        return

    bot_enabled = True
    bot.reply_to(message, "‚úÖ Bot d·ª± ƒëo√°n ƒë√£ ƒë∆∞·ª£c m·ªü l·∫°i b·ªüi Admin.")
    print(f"[INFO] Admin {message.chat.id} ƒë√£ m·ªü bot.")
    
@bot.message_handler(commands=['taokey'])
def generate_code_command(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not (len(args) >= 2 and len(args) <= 3):
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•:\n"
                              "`/taokey <gi√°_tr·ªã> <ph√∫t/gi·ªù/ng√†y/tu·∫ßn/th√°ng> <s·ªë_l∆∞·ª£ng>`\n"
                              "Ho·∫∑c: `/taokey 1 vƒ©nh_vi·ªÖn <s·ªë_l∆∞·ª£ng>`\n"
                              "V√≠ d·ª•: `/taokey 1 ng√†y 5` (t·∫°o 5 key 1 ng√†y)\n"
                              "Ho·∫∑c: `/taokey 1 vƒ©nh_vi·ªÖn 1` (t·∫°o 1 key vƒ©nh vi·ªÖn)", parse_mode='Markdown')
        return
    
    try:
        value_arg = args[0]
        unit_arg = args[1].lower()
        quantity = int(args[2]) if len(args) == 3 else 1 
        
        valid_units = ['ph√∫t', 'gi·ªù', 'ng√†y', 'tu·∫ßn', 'th√°ng', 'vƒ©nh_vi·ªÖn']
        if unit_arg not in valid_units:
            bot.reply_to(message, "ƒê∆°n v·ªã kh√¥ng h·ª£p l·ªá. Ch·ªâ ch·∫•p nh·∫≠n `ph√∫t`, `gi·ªù`, `ng√†y`, `tu·∫ßn`, `th√°ng` ho·∫∑c `vƒ©nh_vi·ªÖn`.", parse_mode='Markdown')
            return
        
        if unit_arg == 'vƒ©nh_vi·ªÖn':
            value = 1 
            if not value_arg.isdigit() or int(value_arg) != 1:
                bot.reply_to(message, "ƒê·ªëi v·ªõi g√≥i `vƒ©nh_vi·ªÖn`, gi√° tr·ªã ph·∫£i l√† `1`.", parse_mode='Markdown')
                return
        else:
            value = int(value_arg)
            if value <= 0:
                bot.reply_to(message, "Gi√° tr·ªã ph·∫£i l·ªõn h∆°n 0.", parse_mode='Markdown')
                return
        
        if quantity <= 0:
            bot.reply_to(message, "S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0.", parse_mode='Markdown')
            return

        generated_keys_list = []
        for _ in range(quantity):
            new_key = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8)) 
            GENERATED_CODES[new_key] = {
                "value": value,
                "type": unit_arg,
                "used_by": None,
                "used_time": None
            }
            generated_keys_list.append(new_key)
        
        save_codes()
        
        response_text = f"‚úÖ ƒê√£ t·∫°o th√†nh c√¥ng {quantity} m√£ key gia h·∫°n **{value_arg} {unit_arg}**:\n\n"
        response_text += "\n".join([f"`{key}`" for key in generated_keys_list])
        response_text += "\n\n_(C√°c m√£ n√†y ch∆∞a ƒë∆∞·ª£c s·ª≠ d·ª•ng)_"
        
        bot.reply_to(message, response_text, parse_mode='Markdown')
        print(f"[INFO] Admin {message.chat.id} ƒë√£ t·∫°o {quantity} key {value_arg} {unit_arg}.")

    except ValueError:
        bot.reply_to(message, "Gi√° tr·ªã ho·∫∑c s·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë nguy√™n.", parse_mode='Markdown')
    except Exception as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi t·∫°o key: {e}", parse_mode='Markdown')

@bot.message_handler(commands=['check'])
def check_prediction_stats(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    total = prediction_stats['total']
    correct = prediction_stats['correct']
    
    if total > 0:
        win_rate = (correct / total) * 100
        stats_text = (
            "üìä **TH·ªêNG K√ä D·ª∞ ƒêO√ÅN BOT** üìä\n\n"
            f"‚úÖ S·ªë phi√™n d·ª± ƒëo√°n ƒë√∫ng: `{correct}`\n"
            f"üî¢ T·ªïng s·ªë phi√™n ƒë√£ d·ª± ƒëo√°n: `{total}`\n"
            f"üìà T·ª∑ l·ªá th·∫Øng: `{win_rate:.2f}%`"
        )
    else:
        stats_text = "üìä **TH·ªêNG K√ä D·ª∞ ƒêO√ÅN BOT** üìä\n\nCh∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ th·ªëng k√™ d·ª± ƒëo√°n."
    
    bot.reply_to(message, stats_text, parse_mode='Markdown')
    print(f"[INFO] Admin {message.chat.id} y√™u c·∫ßu th·ªëng k√™ d·ª± ƒëo√°n.")


@bot.message_handler(commands=['thongke'])
def get_stats(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    total_users = len(user_data)
    active_users = 0
    for user_id_str, user_info in user_data.items():
        is_sub, _ = check_subscription(int(user_id_str))
        if is_sub:
            active_users += 1

    total_codes = len(GENERATED_CODES)
    used_codes = sum(1 for code_info in GENERATED_CODES.values() if code_info.get('used_by') is not None)

    stats_text = (
        "üìä **TH·ªêNG K√ä BOT** üìä\n\n"
        f"üë• T·ªïng s·ªë ng∆∞·ªùi d√πng: `{total_users}`\n"
        f"üü¢ Ng∆∞·ªùi d√πng ƒëang ho·∫°t ƒë·ªông: `{active_users}`\n"
        f"üîë T·ªïng s·ªë m√£ key ƒë√£ t·∫°o: `{total_codes}`\n"
        f"‚úÖ M√£ key ƒë√£ s·ª≠ d·ª•ng: `{used_codes}`"
    )
    bot.reply_to(message, stats_text, parse_mode='Markdown')
    print(f"[INFO] Admin {message.chat.id} y√™u c·∫ßu th·ªëng k√™ chung.")


# --- Flask Routes cho Webhook v√† Keep-Alive ---
@app.route('/' + BOT_TOKEN, methods=['POST']) 
def get_message():
    if request.headers.get('content-type') == 'application/json':
        json_string = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_string)
        bot.process_new_updates([update])
        return "!", 200 
    else:
        print(f"[ERROR] Webhook nh·∫≠n request kh√¥ng ph·∫£i JSON: {request.headers.get('content-type')}")
        return "Unsupported Media Type", 415

@app.route('/')
def home():
    return "Bot is alive and running!"

@app.route('/health')
def health_check():
    return "OK", 200

# --- Kh·ªüi t·∫°o bot v√† c√°c lu·ªìng khi Flask app kh·ªüi ƒë·ªông ---
@app.before_request
def start_bot_threads():
    global bot_initialized
    with bot_init_lock:
        if not bot_initialized:
            print("[INIT] Initializing bot and prediction threads...")
            
            load_user_data()
            load_codes()
            load_prediction_stats() 

            # Thi·∫øt l·∫≠p webhook
            WEBHOOK_URL_BASE = os.environ.get('RENDER_EXTERNAL_HOSTNAME') 
            if not WEBHOOK_URL_BASE:
                print("[WARNING] Bi·∫øn m√¥i tr∆∞·ªùng RENDER_EXTERNAL_HOSTNAME kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y. ƒêang s·ª≠ d·ª•ng URL m·∫∑c ƒë·ªãnh. ƒê·∫£m b·∫£o b·∫°n ƒë√£ thay th·∫ø n√≥!")
                # B·∫°n PH·∫¢I thay th·∫ø d√≤ng d∆∞·ªõi ƒë√¢y b·∫±ng URL Render th·ª±c t·∫ø c·ªßa b·∫°n
                WEBHOOK_URL_BASE = 'YOUR_RENDER_APP_URL.onrender.com' 
            
            WEBHOOK_URL = f"https://{WEBHOOK_URL_BASE}/{BOT_TOKEN}"
            
            print(f"[INIT] C·ªë g·∫Øng ƒë·∫∑t webhook t·ªõi: {WEBHOOK_URL}")
            try:
                bot.remove_webhook() 
                time.sleep(0.1) 
                bot.set_webhook(url=WEBHOOK_URL)
                print("[INIT] Webhook ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh c√¥ng.")
            except Exception as e:
                print(f"[ERROR] L·ªói khi ƒë·∫∑t webhook: {e}")

            prediction_thread = Thread(target=prediction_loop, args=(prediction_stop_event,))
            prediction_thread.daemon = True
            prediction_thread.start()
            print("[INIT] Prediction loop thread ƒë√£ kh·ªüi ƒë·ªông.")
            
            bot_initialized = True
            print("[INIT] Bot ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ho√†n t·∫•t.")

# --- ƒêi·ªÉm kh·ªüi ch·∫°y ch√≠nh cho Gunicorn/Render ---
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    print(f"Starting Flask app locally on port {port}")
    app.run(host='0.0.0.0', port=port, debug=False)

