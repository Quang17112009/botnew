import requests
import time
import logging
import os

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
    CallbackQueryHandler,
    ConversationHandler,
)

# B·∫≠t ghi nh·∫≠t k√Ω (logging)
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# ======================= C·∫§U H√åNH BOT & API =======================
# L·∫•y BOT_TOKEN t·ª´ bi·∫øn m√¥i tr∆∞·ªùng
BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    logger.error("BOT_TOKEN ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p trong bi·∫øn m√¥i tr∆∞·ªùng!")
    exit(1) # Tho√°t n·∫øu kh√¥ng c√≥ token

API_URL = "https://wanglinapiws.up.railway.app/api/taixiu"

# L·∫•y ADMIN_IDS t·ª´ bi·∫øn m√¥i tr∆∞·ªùng v√† chuy·ªÉn ƒë·ªïi th√†nh danh s√°ch s·ªë nguy√™n
ADMIN_IDS_STR = os.getenv("ADMIN_IDS")
if ADMIN_IDS_STR:
    try:
        ADMIN_IDS = [int(x.strip()) for x in ADMIN_IDS_STR.split(',') if x.strip()]
    except ValueError:
        logger.error("ADMIN_IDS trong bi·∫øn m√¥i tr∆∞·ªùng kh√¥ng ph·∫£i l√† c√°c s·ªë nguy√™n h·ª£p l·ªá!")
        ADMIN_IDS = [] # G√°n r·ªóng n·∫øu c√≥ l·ªói
else:
    ADMIN_IDS = [] # M·∫∑c ƒë·ªãnh l√† danh s√°ch r·ªóng n·∫øu kh√¥ng c√≥ bi·∫øn m√¥i tr∆∞·ªùng

# Tr·∫°ng th√°i bot v√† d·ªØ li·ªáu t·∫°m th·ªùi (l∆∞u √Ω: s·∫Ω b·ªã m·∫•t khi bot kh·ªüi ƒë·ªông l·∫°i)
USER_STATES = {}  # {user_id: {"bot_running": False, "game_selected": None}}
KEY_DATA = {}  # {key_name: {"user_id": None, "expiry_time": None, "created_by": None, "activation_time": None}}
GAME_HISTORY = {} # {user_id: [message1, message2, ...]}

# Tr·∫°ng th√°i h·ªôi tho·∫°i cho /chaybot
SELECTING_GAME = 1

# ======================= DANH S√ÅCH C·∫¶U ƒê·∫∏P & C·∫¶U X·∫§U =======================
# C·∫ßu ƒë·∫πp: T·ªïng t·ª´ 9 ƒë·∫øn 12 v√† kh√¥ng ph·∫£i b·ªô 3 (kh√¥ng tr√πng)
cau_dep = {
    (1, 2, 6), (1, 4, 4), (1, 5, 3), (1, 6, 2),
    (2, 1, 6), (2, 2, 5), (2, 3, 4), (2, 4, 3), (2, 5, 2),
    (3, 1, 5), (3, 2, 4), (3, 3, 3), (3, 4, 2), (3, 5, 1),
    (4, 1, 4), (4, 2, 3), (4, 3, 2), (4, 4, 1),
    (5, 1, 4), (5, 3, 1),
    (6, 1, 2), (6, 2, 1),

    (1, 1, 7), (1, 2, 6), (1, 3, 5), (1, 4, 4), (1, 5, 3), (1, 6, 2),
    (2, 1, 6), (2, 2, 5), (2, 3, 4), (2, 4, 3), (2, 5, 2), (2, 6, 1),
    (3, 1, 5), (3, 2, 4), (3, 3, 3), (3, 4, 2), (3, 5, 1),
    (4, 1, 4), (4, 2, 3), (4, 3, 2), (4, 4, 1), (5, 2, 2), (5, 3, 1),
    (6, 1, 2), (6, 2, 1),(3,4,1),(6,4,5),(1,6,3),(2,6,4),(6,1,4),(1,3,2),(2,4,5),(1,3,4),(1,5,1),(3,6,6),(3,6,4),(5,4,6),(3,1,6),(1,3,6),(2,2,4),(1,5,3),(2,4,5),(2,1,2),(6,1,4),(4,6,6),(4,3,5),(3,2,5),(3,4,2),(1,6,4),(6,4,4),(2,3,1),(1,2,1),(6,2,5),(3,1,3),(5,5,1),(4,5,4),(4,6,1),(3,6,1)
}

# C√°c m·∫´u c√≤n l·∫°i l√† c·∫ßu x·∫•u (t·ªïng <9 ho·∫∑c >12 ho·∫∑c l√† b·ªô 3)
cau_xau = {
    (1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4), (1, 1, 5), (1, 1, 6),
    (1, 2, 2), (1, 2, 3), (1, 2, 4), (1, 2, 5),
    (1, 3, 1), (1, 3, 3),
    (1, 4, 1), (1, 4, 2), (1, 4, 3),
     (1, 5, 2),
    (1, 6, 1), (1, 6, 6),
    (2, 1, 1), (2, 1, 3), (2, 1, 4), (2, 1, 5),
    (2, 2, 1), (2, 2, 2), (2, 2, 3),
     (2, 3, 2), (2, 3, 3),
    (2, 4, 1), (2, 4, 2),
    (2, 5, 1), (2, 5, 6),
    (2, 6, 5), (2, 6, 6),
    (3, 1, 1), (3, 1, 2), (3, 1, 4),
    (3, 2, 1), (3, 2, 2), (3, 2, 3),
    (3, 3, 1), (3, 3, 2), (3, 3, 3), (3, 4, 6),
    (3, 5, 5), (3, 5, 6),
    (3, 6, 5),
    (4, 1, 2), (4, 1, 3),
    (4, 2, 1), (4, 2, 2),
    (4, 3, 1), (4, 3, 6),
    (4, 4, 4), (4, 4, 5), (4, 4, 6),
    (4, 5, 5), (4, 5, 6),
    (4, 6, 3), (4, 6, 4), (4, 6, 5),
    (5, 1, 1), (5, 1, 2),
    (5, 2, 1), (5, 2, 6),
    (5, 3, 6),
    (5, 4, 5),
    (5, 5, 5), (5, 5, 6),
    (5, 6, 4), (5, 6, 5), (5, 6, 6),
    (6, 1, 1),
    (6, 2, 6),
    (6, 3, 6),
    (6, 5, 6),
    (6, 6, 1), (6, 6, 2), (6, 6, 3), (6, 6, 4), (6, 6, 5), (6, 6, 6),(5,1,3),(2,6,1),(6,4,6),(5,2,2),(2,1,2),(4,4,1),(1,2,1),(1,3,5)
}

# ======================= H√ÄM X·ª¨ L√ù LOGIC D·ª∞ ƒêO√ÅN =======================
def du_doan_theo_xi_ngau(dice):
    d1, d2, d3 = dice
    total = d1 + d2 + d3
    result_list = []

    for d in [d1, d2, d3]:
        tmp = d + total
        if tmp in [4, 5]:
            tmp -= 4
        elif tmp >= 6:
            tmp -= 6
        result_list.append("T√†i" if tmp % 2 == 0 else "X·ªâu")

    tai_count = result_list.count("T√†i")
    prediction = "T√†i" if tai_count >= 2 else "X·ªâu"

    # Ph√¢n lo·∫°i c·∫ßu theo danh s√°ch ƒë√£ li·ªát k√™
    if dice in cau_dep:
        loai_cau = "C·∫ßu ƒë·∫πp"
    else:
        loai_cau = "C·∫ßu x·∫•u"
        # ƒê·∫£o ng∆∞·ª£c d·ª± ƒëo√°n n·∫øu l√† c·∫ßu x·∫•u
        prediction = "X·ªâu" if prediction == "T√†i" else "T√†i"

    return {
        "xuc_xac": dice,
        "tong": total,
        "cau": loai_cau,
        "du_doan": prediction,
        "chi_tiet": result_list,
        "ket_qua_phien_hien_tai": "T√†i" if total >= 11 else "X·ªâu" # X√°c ƒë·ªãnh k·∫øt qu·∫£ T√†i/X·ªâu c·ªßa phi√™n hi·ªán t·∫°i
    }

async def lay_du_lieu_api():
    """L·∫•y d·ªØ li·ªáu x√∫c x·∫Øc m·ªõi nh·∫•t t·ª´ API."""
    try:
        response = requests.get(API_URL, timeout=5)
        response.raise_for_status() # N√©m l·ªói HTTPError cho c√°c ph·∫£n h·ªìi l·ªói (4xx ho·∫∑c 5xx)
        return response.json()
    except requests.exceptions.RequestException as e:
        logger.error(f"‚ùå L·ªói khi k·∫øt n·ªëi API: {e}")
        return None

async def job_tai_xiu_prediction(context: ContextTypes.DEFAULT_TYPE):
    """Job ch·∫°y ƒë·ªãnh k·ª≥ ƒë·ªÉ g·ª≠i th√¥ng b√°o d·ª± ƒëo√°n T√†i X·ªâu t·ª± ƒë·ªông."""
    data = await lay_du_lieu_api()
    if not data:
        return

    current_session = data.get("Phien")
    current_dice = (
        data.get("Xuc_xac_1"),
        data.get("Xuc_xac_2"),
        data.get("Xuc_xac_3")
    )

    if current_session and all(isinstance(x, int) for x in current_dice):
        for user_id, user_data in list(USER_STATES.items()):
            if user_data.get("bot_running") and user_data.get("game_selected") == "taixiu":
                # Ki·ªÉm tra xem key c√≤n h·ª£p l·ªá kh√¥ng
                if not is_key_valid(user_id) and not is_admin(user_id):
                    USER_STATES[user_id]["bot_running"] = False
                    USER_STATES[user_id]["game_selected"] = None
                    try:
                        await context.bot.send_message(chat_id=user_id, text="Key c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng c√≤n h·ª£p l·ªá. Bot t·ª± ƒë·ªông t·∫Øt th√¥ng b√°o. Vui l√≤ng li√™n h·ªá admin.")
                        logger.info(f"ƒê√£ t·∫Øt bot cho ng∆∞·ªùi d√πng {user_id} v√¨ key h·∫øt h·∫°n.")
                    except Exception as e:
                        logger.error(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn key h·∫øt h·∫°n cho {user_id}: {e}")
                    continue

                last_session_key = f"last_session_{user_id}"
                last_sent_session = context.bot_data.get(last_session_key)

                if current_session != last_sent_session:
                    context.bot_data[last_session_key] = current_session
                    
                    # T√≠nh to√°n k·∫øt qu·∫£ c·ªßa phi√™n hi·ªán t·∫°i (v·ª´a ra)
                    ket_qua_phien_hien_tai = du_doan_theo_xi_ngau(current_dice)
                    
                    # D·ª± ƒëo√°n cho phi√™n TI·∫æP THEO d·ª±a tr√™n current_dice
                    # Logic d·ª± ƒëo√°n c·ªßa b·∫°n ƒë√£ d√πng current_dice ƒë·ªÉ d·ª± ƒëo√°n
                    du_doan_phien_tiep_theo = ket_qua_phien_hien_tai['du_doan'] # D·ª± ƒëo√°n t·ª´ h√†m du_doan_theo_xi_ngau

                    message = (
                        f"üéÆ **K·∫æT QU·∫¢ PHI√äN HI·ªÜN T·∫†I Sunwin** üéÆ\n"
                        f"Phi√™n: `{current_session}` | K·∫øt qu·∫£: **{ket_qua_phien_hien_tai['ket_qua_phien_hien_tai']}** (T·ªïng: {ket_qua_phien_hien_tai['tong']})\n"
                        f"Chi ti·∫øt: {ket_qua_phien_hien_tai['xuc_xac']} | Lo·∫°i c·∫ßu: {ket_qua_phien_hien_tai['cau']}\n\n"
                        f"**D·ª± ƒëo√°n cho phi√™n ti·∫øp theo:**\n"
                        f"üî¢ Phi√™n: `{current_session + 1}`\n"
                        f"ü§ñ D·ª± ƒëo√°n: **{du_doan_phien_tiep_theo}**"
                    )
                    
                    # L∆∞u v√†o l·ªãch s·ª≠ phi√™n
                    if user_id not in GAME_HISTORY:
                        GAME_HISTORY[user_id] = []
                    GAME_HISTORY[user_id].insert(0, message) # Th√™m v√†o ƒë·∫ßu danh s√°ch
                    if len(GAME_HISTORY[user_id]) > 10: # Gi·ªØ 10 phi√™n g·∫ßn nh·∫•t
                        GAME_HISTORY[user_id].pop()

                    try:
                        await context.bot.send_message(chat_id=user_id, text=message, parse_mode="Markdown")
                        logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o cho ng∆∞·ªùi d√πng {user_id} v·ªÅ phi√™n {current_session} v√† d·ª± ƒëo√°n {current_session + 1}")
                    except Exception as e:
                        logger.error(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn cho ng∆∞·ªùi d√πng {user_id}: {e}")
                else:
                    logger.info(f"Phi√™n {current_session} ch∆∞a thay ƒë·ªïi ho·∫∑c ƒë√£ ƒë∆∞·ª£c g·ª≠i cho ng∆∞·ªùi d√πng {user_id}.")
            else:
                logger.debug(f"Bot kh√¥ng ch·∫°y ho·∫∑c ch∆∞a ch·ªçn game cho ng∆∞·ªùi d√πng {user_id}.")
    else:
        logger.warning("‚ö†Ô∏è D·ªØ li·ªáu API kh√¥ng ƒë·∫ßy ƒë·ªß ho·∫∑c kh√¥ng h·ª£p l·ªá.")


# ======================= H√ÄM H·ªñ TR·ª¢ KI·ªÇM TRA QUY·ªÄN =======================
def is_admin(user_id):
    """Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ ph·∫£i admin kh√¥ng."""
    return user_id in ADMIN_IDS

def is_key_valid(user_id):
    """Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ key h·ª£p l·ªá v√† c√≤n h·∫°n kh√¥ng."""
    for key, data in KEY_DATA.items():
        if data["user_id"] == user_id:
            # N·∫øu key kh√¥ng c√≥ th·ªùi gian h·∫øt h·∫°n ho·∫∑c c√≤n h·∫°n
            if data["expiry_time"] is None or data["expiry_time"] > time.time():
                return True
    return False

# ======================= H√ÄM X·ª¨ L√ù L·ªÜNH BOT =======================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Hi·ªÉn th·ªã th√¥ng tin ch√†o m·ª´ng v√† h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng."""
    user = update.effective_user
    await update.message.reply_html(
        f"Xin ch√†o {user.mention_html()}! üëã\n"
        "Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi bot d·ª± ƒëo√°n T√†i X·ªâu.\n"
        "S·ª≠ d·ª•ng c√°c l·ªánh b√™n d∆∞·ªõi ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi bot.\n"
        "üîî **H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG BOT**\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "üîë **L·ªánh c∆° b·∫£n:**\n"
        "- `/start`: Hi·ªÉn th·ªã th√¥ng tin ch√†o m·ª´ng\n"
        "- `/key <key>`: Nh·∫≠p key ƒë·ªÉ k√≠ch ho·∫°t bot\n"
        "- `/chaybot`: B·∫≠t nh·∫≠n th√¥ng b√°o d·ª± ƒëo√°n t·ª± ƒë·ªông (s·∫Ω h·ªèi ch·ªçn game)\n"
        "- `/tatbot`: T·∫Øt nh·∫≠n th√¥ng b√°o d·ª± ƒëo√°n t·ª± ƒë·ªông\n"
        "- `/lichsu`: Xem l·ªãch s·ª≠ 10 phi√™n g·∫ßn nh·∫•t c·ªßa game b·∫°n ƒëang ch·ªçn\n\n"
        "üõ°Ô∏è **L·ªánh admin:**\n"
        "- `/taokey <t√™n_key> [s·ªë_l∆∞·ª£ng] [ƒë∆°n_v·ªã_th·ªùi_gian]`: T·∫°o key m·ªõi. V√≠ d·ª•: `/taokey MYKEY123 1 ng√†y`, `/taokey VIPKEY 24 gi·ªù`\n"
        "- `/lietkekey`: Li·ªát k√™ t·∫•t c·∫£ key v√† tr·∫°ng th√°i s·ª≠ d·ª•ng\n"
        "- `/xoakey <key>`: X√≥a key kh·ªèi h·ªá th·ªëng\n"
        "- `/themadmin <id>`: Th√™m ID ng∆∞·ªùi d√πng l√†m admin\n"
        "- `/xoaadmin <id>`: X√≥a ID ng∆∞·ªùi d√πng kh·ªèi admin\n"
        "- `/danhsachadmin`: Xem danh s√°ch c√°c ID admin\n"
        "- `/broadcast [tin nh·∫Øn]`: G·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng\n\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "üë• Li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ th√™m."
    )

async def handle_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """X·ª≠ l√Ω l·ªánh nh·∫≠p key ƒë·ªÉ k√≠ch ho·∫°t bot."""
    user_id = update.effective_user.id
    if len(context.args) == 1:
        key = context.args[0]
        if key in KEY_DATA:
            if KEY_DATA[key]["user_id"] is None:
                KEY_DATA[key]["user_id"] = user_id
                KEY_DATA[key]["activation_time"] = time.time()
                await update.message.reply_text(f"Key `{key}` ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t th√†nh c√¥ng cho b·∫°n! üéâ", parse_mode="Markdown")
                logger.info(f"Key {key} activated by user {user_id}")
            elif KEY_DATA[key]["user_id"] == user_id:
                await update.message.reply_text(f"Key `{key}` ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t b·ªüi b·∫°n tr∆∞·ªõc ƒë√≥ r·ªìi. üëç", parse_mode="Markdown")
            else:
                await update.message.reply_text(f"Key `{key}` ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ng∆∞·ªùi kh√°c. Vui l√≤ng li√™n h·ªá admin. üò¢", parse_mode="Markdown")
        else:
            await update.message.reply_text("Key kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i. Vui l√≤ng ki·ªÉm tra l·∫°i. ü§î")
    else:
        await update.message.reply_text("Vui l√≤ng nh·∫≠p key sau l·ªánh /key. V√≠ d·ª•: `/key YOURKEY123`", parse_mode="Markdown")

async def chaybot_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """B·∫Øt ƒë·∫ßu qu√° tr√¨nh b·∫≠t bot v√† ch·ªçn game b·∫±ng n√∫t inline."""
    user_id = update.effective_user.id
    if not is_key_valid(user_id) and not is_admin(user_id):
        await update.message.reply_text("B·∫°n c·∫ßn c√≥ key h·ª£p l·ªá ho·∫∑c l√† admin ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y. Vui l√≤ng nh·∫≠p key b·∫±ng l·ªánh /key ho·∫∑c li√™n h·ªá admin.")
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton("T√†i X·ªâu", callback_data="game_taixiu")],
        # Th√™m c√°c game kh√°c ·ªü ƒë√¢y n·∫øu c√≥
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Vui l√≤ng ch·ªçn game b·∫°n mu·ªën nh·∫≠n th√¥ng b√°o:", reply_markup=reply_markup)
    return SELECTING_GAME

async def select_game(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """X·ª≠ l√Ω l·ª±a ch·ªçn game t·ª´ ng∆∞·ªùi d√πng th√¥ng qua callback query."""
    query = update.callback_query
    await query.answer() # B√°o hi·ªáu ƒë√£ nh·∫≠n callback
    
    user_id = query.from_user.id
    game_selected = query.data.replace("game_", "")

    if user_id not in USER_STATES:
        USER_STATES[user_id] = {}
    
    USER_STATES[user_id]["bot_running"] = True
    USER_STATES[user_id]["game_selected"] = game_selected

    await query.edit_message_text(f"B·∫°n ƒë√£ ch·ªçn game **{game_selected.upper()}**. Bot s·∫Ω b·∫Øt ƒë·∫ßu g·ª≠i th√¥ng b√°o d·ª± ƒëo√°n t·ª± ƒë·ªông cho b·∫°n. üöÄ", parse_mode="Markdown")
    logger.info(f"Bot started for user {user_id} for game {game_selected}")
    return ConversationHandler.END


async def tatbot(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """T·∫Øt nh·∫≠n th√¥ng b√°o d·ª± ƒëo√°n t·ª± ƒë·ªông."""
    user_id = update.effective_user.id
    if user_id in USER_STATES and USER_STATES[user_id].get("bot_running"):
        USER_STATES[user_id]["bot_running"] = False
        USER_STATES[user_id]["game_selected"] = None
        await update.message.reply_text("Bot ƒë√£ ng·ª´ng g·ª≠i th√¥ng b√°o d·ª± ƒëo√°n t·ª± ƒë·ªông cho b·∫°n. üëã")
        logger.info(f"Bot stopped for user {user_id}")
    else:
        await update.message.reply_text("Bot hi·ªán kh√¥ng ch·∫°y. B·∫°n c√≥ th·ªÉ b·∫≠t l·∫°i b·∫±ng l·ªánh /chaybot.")

async def lichsu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Xem l·ªãch s·ª≠ 10 phi√™n g·∫ßn nh·∫•t c·ªßa game b·∫°n ƒëang ch·ªçn."""
    user_id = update.effective_user.id
    if user_id not in GAME_HISTORY or not GAME_HISTORY[user_id]:
        await update.message.reply_text("B·∫°n ch∆∞a c√≥ l·ªãch s·ª≠ d·ª± ƒëo√°n n√†o. Vui l√≤ng ch·∫°y bot tr∆∞·ªõc b·∫±ng l·ªánh /chaybot.")
        return

    history_messages = GAME_HISTORY[user_id]
    # L·ªãch s·ª≠ ƒë∆∞·ª£c l∆∞u d∆∞·ªõi d·∫°ng Markdown, n√™n ch·ªâ c·∫ßn n·ªëi chu·ªói
    response = "üìú **L·ªãch s·ª≠ 10 phi√™n g·∫ßn nh·∫•t:**\n\n" + "\n---\n".join(history_messages)
    await update.message.reply_text(response, parse_mode="Markdown")

# ======================= L·ªÜNH ADMIN =======================

async def taokey(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """T·∫°o key m·ªõi. V√≠ d·ª•: /taokey MYKEY123 1 ng√†y, /taokey VIPKEY 24 gi·ªù."""
    user_id = update.effective_user.id
    if not is_admin(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y. üö´")
        return

    if len(context.args) < 1:
        await update.message.reply_text("C√∫ ph√°p: `/taokey <t√™n_key> [s·ªë_l∆∞·ª£ng] [ƒë∆°n_v·ªã_th·ªùi_gian]`\nV√≠ d·ª•: `/taokey MYKEY123 1 ng√†y`, `/taokey VIPKEY 24 gi·ªù`", parse_mode="Markdown")
        return

    key_name = context.args[0]
    expiry_time = None

    if len(context.args) >= 3:
        try:
            amount = int(context.args[1])
            unit = context.args[2].lower()
            if unit in ["ng√†y", "day"]:
                expiry_time = time.time() + amount * 24 * 3600
            elif unit in ["gi·ªù", "h", "hour", "hours"]:
                expiry_time = time.time() + amount * 3600
            elif unit in ["ph√∫t", "m", "minute", "minutes"]:
                expiry_time = time.time() + amount * 60
            else:
                await update.message.reply_text("ƒê∆°n v·ªã th·ªùi gian kh√¥ng h·ª£p l·ªá. Vui l√≤ng d√πng 'ng√†y', 'gi·ªù', 'ph√∫t'.")
                return
        except ValueError:
            await update.message.reply_text("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë nguy√™n.")
            return

    if key_name in KEY_DATA:
        await update.message.reply_text(f"Key `{key_name}` ƒë√£ t·ªìn t·∫°i. Vui l√≤ng ch·ªçn t√™n kh√°c.", parse_mode="Markdown")
        return

    KEY_DATA[key_name] = {
        "user_id": None,
        "expiry_time": expiry_time,
        "created_by": user_id,
        "created_at": time.time(),
        "activation_time": None # Kh·ªüi t·∫°o l√† None
    }
    expiry_msg = f"h·∫øt h·∫°n v√†o `{time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(expiry_time))}`" if expiry_time else "kh√¥ng c√≥ th·ªùi gian h·∫øt h·∫°n"
    await update.message.reply_text(f"Key `{key_name}` ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng, {expiry_msg}. üéâ", parse_mode="Markdown")
    logger.info(f"Key {key_name} created by admin {user_id} with expiry {expiry_time}")

async def lietkekey(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Li·ªát k√™ t·∫•t c·∫£ key v√† tr·∫°ng th√°i s·ª≠ d·ª•ng."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y. üö´")
        return

    if not KEY_DATA:
        await update.message.reply_text("Ch∆∞a c√≥ key n√†o ƒë∆∞·ª£c t·∫°o.")
        return

    response = "üîë **Danh s√°ch Key:**\n\n"
    for key, data in KEY_DATA.items():
        status = "Ch∆∞a s·ª≠ d·ª•ng"
        user_info = ""
        expiry_info = ""
        activation_info = ""

        if data["user_id"]:
            status = "ƒê√£ s·ª≠ d·ª•ng"
            user_info = f" b·ªüi `{data['user_id']}`"
            if data["activation_time"]:
                activation_info = f" (k√≠ch ho·∫°t: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data['activation_time']))})"
            
        if data["expiry_time"]:
            if data["expiry_time"] > time.time():
                expiry_info = f" | H·∫°n: `{time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data['expiry_time']))}`"
            else:
                expiry_info = " | ƒê√£ h·∫øt h·∫°n ‚è≥"
                status = "ƒê√£ h·∫øt h·∫°n" # C·∫≠p nh·∫≠t tr·∫°ng th√°i n·∫øu key ƒë√£ h·∫øt h·∫°n

        response += f"- `{key}`: {status}{user_info}{activation_info}{expiry_info}\n"
    await update.message.reply_text(response, parse_mode="Markdown")

async def xoakey(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """X√≥a key kh·ªèi h·ªá th·ªëng."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y. üö´")
        return

    if len(context.args) == 1:
        key_to_delete = context.args[0]
        if key_to_delete in KEY_DATA:
            del KEY_DATA[key_to_delete]
            await update.message.reply_text(f"Key `{key_to_delete}` ƒë√£ ƒë∆∞·ª£c x√≥a. ‚úÖ", parse_mode="Markdown")
            logger.info(f"Key {key_to_delete} deleted by admin {update.effective_user.id}")
        else:
            await update.message.reply_text("Key kh√¥ng t·ªìn t·∫°i. ü§î")
    else:
        await update.message.reply_text("Vui l√≤ng cung c·∫•p key c·∫ßn x√≥a. V√≠ d·ª•: `/xoakey MYKEY123`", parse_mode="Markdown")

async def themadmin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Th√™m ID ng∆∞·ªùi d√πng l√†m admin."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y. üö´")
        return

    if len(context.args) == 1:
        try:
            new_admin_id = int(context.args[0])
            if new_admin_id not in ADMIN_IDS:
                ADMIN_IDS.append(new_admin_id)
                await update.message.reply_text(f"ID `{new_admin_id}` ƒë√£ ƒë∆∞·ª£c th√™m v√†o danh s√°ch admin. üõ°Ô∏è", parse_mode="Markdown")
                logger.info(f"Admin {new_admin_id} added by admin {update.effective_user.id}")
            else:
                await update.message.reply_text("ID n√†y ƒë√£ l√† admin r·ªìi. üòä")
        except ValueError:
            await update.message.reply_text("ID kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë nguy√™n.")
    else:
        await update.message.reply_text("Vui l√≤ng cung c·∫•p ID ng∆∞·ªùi d√πng c·∫ßn th√™m. V√≠ d·ª•: `/themadmin 123456789`", parse_mode="Markdown")

async def xoaadmin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """X√≥a ID ng∆∞·ªùi d√πng kh·ªèi admin."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y. üö´")
        return

    if len(context.args) == 1:
        try:
            admin_id_to_remove = int(context.args[0])
            if admin_id_to_remove in ADMIN_IDS:
                ADMIN_IDS.remove(admin_id_to_remove)
                await update.message.reply_text(f"ID `{admin_id_to_remove}` ƒë√£ ƒë∆∞·ª£c x√≥a kh·ªèi danh s√°ch admin. üóëÔ∏è", parse_mode="Markdown")
                logger.info(f"Admin {admin_id_to_remove} removed by admin {update.effective_user.id}")
            else:
                await update.message.reply_text("ID n√†y kh√¥ng ph·∫£i l√† admin. ü§î")
        except ValueError:
            await update.message.reply_text("ID kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë nguy√™n.")
    else:
        await update.message.reply_text("Vui l√≤ng cung c·∫•p ID ng∆∞·ªùi d√πng c·∫ßn x√≥a. V√≠ d·ª•: `/xoaadmin 123456789`", parse_mode="Markdown")

async def danhsachadmin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Xem danh s√°ch c√°c ID admin."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y. üö´")
        return
    
    if not ADMIN_IDS:
        await update.message.reply_text("Ch∆∞a c√≥ admin n√†o ƒë∆∞·ª£c th√™m.")
        return

    response = "üõ°Ô∏è **Danh s√°ch Admin:**\n"
    for admin_id in ADMIN_IDS:
        response += f"- `{admin_id}`\n"
    await update.message.reply_text(response, parse_mode="Markdown")

async def broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """G·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y. üö´")
        return

    message_text = " ".join(context.args)
    if not message_text:
        await update.message.reply_text("Vui l√≤ng cung c·∫•p n·ªôi dung tin nh·∫Øn ƒë·ªÉ broadcast. V√≠ d·ª•: `/broadcast Ch√†o m·ªçi ng∆∞·ªùi, bot ƒëang c·∫≠p nh·∫≠t t√≠nh nƒÉng m·ªõi!`", parse_mode="Markdown")
        return

    success_count = 0
    fail_count = 0
    sent_to_users = set() # D√πng set ƒë·ªÉ tr√°nh g·ª≠i tr√πng l·∫∑p n·∫øu user c√≥ nhi·ªÅu key ho·∫∑c ƒë∆∞·ª£c l∆∞u nhi·ªÅu l·∫ßn

    # G·ª≠i ƒë·∫øn t·∫•t c·∫£ user ƒë√£ t·ª´ng t∆∞∆°ng t√°c v·ªõi bot ho·∫∑c c√≥ key
    # T·∫°o m·ªôt set duy nh·∫•t ch·ª©a t·∫•t c·∫£ user_id
    all_known_users = set(USER_STATES.keys())
    for key_data in KEY_DATA.values():
        if key_data["user_id"]:
            all_known_users.add(key_data["user_id"])

    for user_id in all_known_users:
        if user_id in sent_to_users: # N·∫øu ƒë√£ g·ª≠i cho user n√†y r·ªìi, b·ªè qua
            continue 

        try:
            await context.bot.send_message(chat_id=user_id, text=f"üì¢ **TH√îNG B√ÅO T·ª™ ADMIN:**\n\n{message_text}", parse_mode="Markdown")
            success_count += 1
            sent_to_users.add(user_id) # ƒê√°nh d·∫•u ƒë√£ g·ª≠i
        except Exception as e:
            logger.error(f"Kh√¥ng th·ªÉ g·ª≠i broadcast ƒë·∫øn ng∆∞·ªùi d√πng {user_id}: {e}")
            fail_count += 1
    
    await update.message.reply_text(f"ƒê√£ g·ª≠i broadcast th√†nh c√¥ng ƒë·∫øn {success_count} ng∆∞·ªùi d√πng, th·∫•t b·∫°i {fail_count} ng∆∞·ªùi d√πng.")

async def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Ph·∫£n h·ªìi khi ng∆∞·ªùi d√πng g·ª≠i l·ªánh kh√¥ng x√°c ƒë·ªãnh."""
    await update.message.reply_text("Xin l·ªói, t√¥i kh√¥ng hi·ªÉu l·ªánh ƒë√≥. Vui l√≤ng xem `/start` ƒë·ªÉ bi·∫øt c√°c l·ªánh ƒë∆∞·ª£c h·ªó tr·ª£.")

# ======================= CH·∫†Y BOT =======================
def main() -> None:
    """H√†m ch√≠nh ƒë·ªÉ ch·∫°y bot."""
    application = Application.builder().token(BOT_TOKEN).build()

    # Th√™m JobQueue ƒë·ªÉ ch·∫°y job ƒë·ªãnh k·ª≥
    # Job n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi m·ªói 2 gi√¢y ƒë·ªÉ ki·ªÉm tra API v√† g·ª≠i th√¥ng b√°o
    job_queue = application.job_queue
    job_queue.run_repeating(job_tai_xiu_prediction, interval=2, first=0)


    # Handlers cho l·ªánh c∆° b·∫£n
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("key", handle_key))

    # ConversationHandler cho /chaybot ƒë·ªÉ qu·∫£n l√Ω lu·ªìng ch·ªçn game
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("chaybot", chaybot_start)],
        states={
            SELECTING_GAME: [CallbackQueryHandler(select_game, pattern="^game_")],
        },
        fallbacks=[CommandHandler("cancel", tatbot)], # L·ªánh ƒë·ªÉ tho√°t kh·ªèi h·ªôi tho·∫°i
    )
    application.add_handler(conv_handler)
    
    application.add_handler(CommandHandler("tatbot", tatbot))
    application.add_handler(CommandHandler("lichsu", lichsu))

    # Handlers cho l·ªánh admin
    application.add_handler(CommandHandler("taokey", taokey))
    application.add_handler(CommandHandler("lietkekey", lietkekey))
    application.add_handler(CommandHandler("xoakey", xoakey))
    application.add_handler(CommandHandler("themadmin", themadmin))
    application.add_handler(CommandHandler("xoaadmin", xoaadmin))
    application.add_handler(CommandHandler("danhsachadmin", danhsachadmin))
    application.add_handler(CommandHandler("broadcast", broadcast))

    # Handler cho c√°c tin nh·∫Øn kh√¥ng ph·∫£i l·ªánh
    application.add_handler(MessageHandler(filters.COMMAND, unknown))

    # Kh·ªüi ƒë·ªông bot
    logger.info("Bot ƒëang kh·ªüi ƒë·ªông...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
